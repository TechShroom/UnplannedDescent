
import org.apache.tools.ant.taskdefs.condition.Os

boolean isNix() {
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        return false
    }
    return true
}

boolean tryDelete(tempFile, logger = false) {
    if (logger)
        println("Attempting to delete " + tempFile.getAbsolutePath());
    tempFile.setWritable(true)
    if (!tempFile.exists() && logger)
        println("  Doesn't exist")
    else if (!tempFile.canWrite() && logger) {
        //println("  No write permission")
    } else {
        if (tempFile.delete() && logger)
            println("  Deleted!")
        else if (logger)
            println("  Delete failed - reason unknown")
    }
}

// directories don't delete well. This fixes that at the cost of recursive-ness
void forceDelete(dirorfile, exclude = []) {
    if (!dirorfile.isDirectory()) {
        if (!tryDelete(dirorfile)) {
            dirorfile.deleteOnExit()
        }
        return
    }
    def dir = dirorfile
    def except = true
    while (except) {
        except = false
        try {
            dir.eachFileRecurse { f ->
                def passes = true
                exclude.each {
                    passes = passes && f == new File(dir, it)
                }
                if (passes) {
                    if (!tryDelete(f)) {
                        f.deleteOnExit()
                    } else {
                        def overf = f
                        while ((overf = overf.getParentFile()) != dir) {
                            tryDelete(overf)
                        }
                    }
                }
            }
        } catch (FileNotFoundException nothere) {
            except = true
        }
    }
}

void getFromGit(directory, giturl) {
    def dfile = file(directory)
    // ensure it is there
    dfile.mkdir()
    def gfile = new File(dfile, ".git")
    println gfile
    // check for git
    if (gfile.exists()) {
        forceDelete(gfile)
    }
    exec {
        workingDir dfile
        commandLine 'git', 'init'
    }
    exec {
        workingDir dfile
        commandLine 'git', 'remote', 'add', 'origin', giturl
    }
    exec {
        workingDir dfile
        commandLine 'git', 'pull', 'origin', 'master'
    }

    // clean up git, makes it not break UD git
    forceDelete(gfile)
}

task cleanDirectory() {
    def thisdir = file('.')
    def exclude = ['ant-delegate.sh', 'ant-delegate.bat', 'build.gradle', 'lib/lwjgl3.jar']
    forceDelete(thisdir, exclude)
}

gradle.taskGraph.whenReady {
    gradle.taskGraph.getAllTasks().last().finalizedBy(cleanDirectory)
}

// the following gets lwjgl3 into the current directory
task setupDirectory(dependsOn: ['cleanDirectory']) << {
    
    if (project._property('travis')) {
        getFromGit('.', 'https://github.com/TechShroom/lwjgl3-precompiled')
        return
    }
    getFromGit('.', 'https://github.com/LWJGL/lwjgl3')
    // getFromGit('generated', 'https://github.com/kenzierocks/lwjgl3-generated')
}

setupDirectory.onlyIf { !file("lib/lwjgl3.jar").exists() ||
                        (_hasProperty("rebuild-lwjgl3") && _property("rebuild-lwjgl3").toBoolean()) }

task jar(type: Zip, dependsOn: 'buildLWJGL') {
    archiveName = 'lwjgl3.jar'
    destinationDir = file('lib')
    from 'bin/Core'
}

jar.onlyIf { !file("lib/lwjgl3.jar").exists() ||
                        (_hasProperty("rebuild-lwjgl3") && _property("rebuild-lwjgl3").toBoolean()) }

task buildLWJGL(type: Exec, dependsOn: ['setupDirectory']) {
    if (project._property('travis')) {
        commandLine 'echo', 'Travis CI cannot build, jar will use precompiled classes.'
        return
    }
    // building is all sorts of weirdness for natives. If you have trouble,
    // visit https://github.com/LWJGL/lwjgl3/wiki/4.3.-Setup for some help
    if (isNix()) {
        commandLine 'sh', 'ant-delegate.sh'
    } else {
        commandLine 'cmd', '/c', 'ant-delegate.bat'
    }
}
