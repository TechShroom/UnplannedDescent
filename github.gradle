apply from: 'util.gradle', to: project

println "Configuring $name's GitHub manager..."

buildscript {
    repositories {
        mavenCentral()
    }
    
    
    dependencies {
        classpath 'com.jcabi:jcabi-github:0.8.1'
    }
}

import com.jcabi.github.*
import com.jcabi.github.wire.CarefulWire
import com.jcabi.http.wire.*
import javax.ws.rs.core.HttpHeaders
import org.codehaus.groovy.runtime.EncodingGroovyMethods

ext.createGithub = { oauth, user, pass ->
    def rt = null
    def method = 0 // 0 = none, 1 = user/pass, 2 = oauth
    if (oauth == "" || oauth == null) {
        if (user == "" || user == null) {
            rt = new RtGithub()
            method = 0
        } else {
            rt = new RtGithub(user, pass)
            method = 1
        }
    } else {
        rt = new RtGithub(oauth)
        method = 2
    }
    def rt_req = rt.entry().through(RetryWire.class).through(CarefulWire.class, 50)
    
    if (method == 1) {
        // patch auth header
        rt_req = rt_req.header(
            HttpHeaders.AUTHORIZATION,
            String.format("Basic %s", EncodingGroovyMethods.encodeBase64("$user:$pass".getBytes()))
        )
    }
    
    ext.githubAuthMethod = method
    
    return new RtGithub(rt_req)
}

ext.getLastRelSmart = { releases ->
    def lastll = releases?.iterate()?.iterator()?.toList()
    def last = null
    if (lastll.size() != 0) {
        last = lastll.last()
    }
    return last == null ? null : new Release.Smart(last)
}

import java.util.regex.Matcher
import java.util.regex.Pattern

// note: the following requires a tag version formatted as follows:
// "v$major.$minor.$patch"
// ('v' + major + '.' + minor + '.' + patch)
// and a project version formatted as follows:
// "$major.$minor.$patch"
// (major + '.' + minor + '.' + patch)

ext.versionNext = { relsm ->
    def pver = project.version
    def mat = pver =~ /(\d)\.(\d)\.(\d).*/
    if (!mat) {
        throw new IllegalArgumentException("project version ($pver) in wrong format")
    }
    
    print "Comparing $pver..."
    
    def pmajor = mat.group(1)
    def pminor = mat.group(2)
    def ppatch = mat.group(3)
    
    def lver = relsm?.tag()
    if (lver) {
        print "to $lver..."
    }
    println ""
    mat = lver =~ /v(\d)\.(\d)\.(\d)/
    if (mat) {
        def major = mat.group(1)
        def minor = mat.group(2)
        def patch = mat.group(3)
        if (pmajor > major + 1) {
            throw new RuntimeException("Too large of a jump: $major -> $pmajor")
        }
        if (pminor > minor + 1) {
            throw new RuntimeException("Too large of a jump: $minor -> $pminor")
        }
        if (ppatch > patch + 1) {
            throw new RuntimeException("Too large of a jump: $patch -> $ppatch")
        }
        println "Going from $lver -> $pver"
    } else {
        // assume version is right
        println "Assuming version v$pver is correct!"
    }
    return pver
}

task release(dependsOn: 'doBuild') << {
    def projCoord = new Coordinates.Simple("TechShroom", "UnplannedDescent")
    def git = project.createGithub(
        project._property("oauth"),
        project._property("user"),
        project._property("password")
    )
    if (project.githubAuthMethod == 0) {
        // no auth, no upload!
        throw new RuntimeException("No authorization for upload!")
    }
    def proj = git.repos().get(projCoord)
    def releases = proj.releases()
    def rs = project.getLastRelSmart(releases)
    def ver = project.versionNext(rs)
    
    if ("v$ver" == rs?.tag()) {
        println "Version unchanged."
        return
    }
    
    def nrs = new Release.Smart(releases.create("v$ver"))
    if (_hasProperty("prerelease")) {
        nrs.prerelease(_property("prerelease").toBoolean())
    }
}

println "Complete."
